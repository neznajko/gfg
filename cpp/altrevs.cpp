// @@@@@@@@@@@@@@@@@@@@@ | | | | | | | | | | | | . . . . . . . .
// @@@@@@@@@@@@@@@@@@@@@ | | | | | | | | | | | | . . . . . . . .
// @@@@@@@@@@@@@@@@@@@@@ | | | | | | | | | | | | . . . . . . . .
// @@                 @@ | |                 | | . .            
// @@     @@@@@@@     @@ | |     | | | |     | | . .     . . . .
// @@                 @@ | |                 | | . .            
// @@@@@@@@@@@@@@@@@@@@@ | | | | | | | | | | | | . . . . . . . .
// @@                 @@ | |                 | | . .            
// @@     @@@@@@@     @@ | |     | | | |     | | . .     . . . .
// @@                 @@ | |                 | | . .            
// @@     @@@@@@@     @@ | |     | | | |     | | . .     . . . .
// @@                 @@ | |                 | | . .            
// @@     @@@@@@@     @@ | |     | | | |     | | . .     . . . .
// @@                 @@ | |                 | | . .            
// @@@@@@@@@@@@@@@@@@@@@ | | | | | | | | | | | | @@@@@@@@@@@@@@@
// @@@     @@@@@@     @@ | |     | | | |     | | @@@@     @@@@@@
// @@     @@@@@@@     @@ | |     | | | |     | | @@@     @@@@@@@
// %%     %%%%%%%     %% - -     - - - -     - - %%%     %%%%%%%
// ===     ======     == " "     " " " "     " " ====     ======
// --------------------- ' ' ' ' ' ' ' ' ' ' ' ' ---------------
// ``                 `` ` `                 ` ` ` `            
// Reverse alternate nodes in Link List, 員、イン、in, employee
////////////////////////////////////////////////////////////////
// Given a linked list, you have to perform the following task:
// Extract the alternative nodes starting from second node.
// Reverse the extracted list.
// Append the extracted list at the end of the original list.
////////////////////////////////////////////////////////////////
// LinkedList = 10->4->9->1->3->5->9->4
// Output: 10 9 3 9 4 5 1 4
// Explanation: Alternative nodes in the given linked list are 
// 4,1,5,4. Reversing the alternative nodes from the given list, 
// and then appending them to the end of the list results in a 
// list 10->9->3->9->4->5->1->4.
////////////////////////////////////////////////////////////////
// LinkedList = 1->2->3->4->5
// Output: 1 3 5 4 2 
// Explanation: ...
////////////////////////////////////////////////////////////////
// Expected Time Complexity: O(N)
// Expected Auxiliary Space: O(1)
////////////////////////////////////////////////////////////////
// 1 <= N <= 10^5
// 0 <= Node_value <= 10^9
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
// weit far ausladend protruding befinden to be gleicher similar
// weit  \\ ausladend  \\\\\\\\\ befinden  \\ \ gleicher  \\\\\\
// weit   \ ausladend   \\\\\\\\ befinden   \\  gleicher   \\\\\
//  \\\\    ausladend    \\\\\\\ befinden    \\ gleicher    \\\\
//   \\\\    \\\\\\\\\    \\\\\\ befinden     \ gleicher     \\\
// schenkel leg stelle point \\\ befinden      \ \\\\\\\\     \\
// schenkel  \\ stelle  \\\\\ \\\ \\\\\\\\      \ \\\\\\\\     \
// schenkel   \ stelle   \\\\\ \\\ \\\\\\\\      \ \\\\\\\\     
// schenkel    \ \\\\\\   \\\\\ \\\ \\\\\\\\      \ \\\\\\\\
// schenkel     \ \\\\\\   \\\\\ \\\ \\\\\\\\      \ \\\\\\\\
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>                                 
////////////////////////////////////////////////////////////////
//     tourist office | verkehrsamt
//     ```um`die`Ecke | round`the`corner
// in the next`street | die`nächste`Straße
// `` ``` `fahren`Sie | drive..```` `````` 
////////////////////////////////////////////////////////////////
struct Node{ int data;struct Node*next;Node(int x){ data=x;next=
NULL;}};////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void printList(struct Node*node){while(node!=NULL){printf("%d ",
node->data);node=node->next;}printf("\n");}/////////////////////
////////////////////////////////////////////////////////////////
struct Node *start=NULL;////////////////////////////////////////
////////////////////////////////////////////////////////////////
void insert(){int n,value;cin>>n;struct Node*temp;for(int i=0;i<
n;i++){ cin>>value; if(i==0){ start=new Node(value); temp=start;
continue; }else{ temp->next=new Node(value); temp=temp->next;}}}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Solution {
public:
    void rearrange( Node* h );};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node* detach_next( Node* p ){
    Node* n{ p->next };
    p->next = n->next;
    return n;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void attach( Node* ahead, Node* p ){
    p->next = ahead->next;
    ahead->next = p;
}
////////////////////////////////////////////////////////////////
// (a) 34 さんじゅうよん (b) 67 ろくじゅうなな（しち）
// (c) 83 はちじゅうさん (d) 99 きゅうじゅうきゅう（く）
// (e) 125 ひゃくにじゅうご (f) 515 ごひゃくじゅうご
// (g) 603 ろっぴゃくさん (h) 850 はっぴゃくごじゅう 
// (i) 1,300 せんさんびゃく (j) 3,400 さんぜにょんひゃく
// (k) 8,900 はっせんきゅうひゃく (l) 35,000 さんまんごせん
// (m) 64,500 ろくまんよんせんごひゃく
// (n) 92,340 きゅうまんにせんさんびゃくよんじゅう
////////////////////////////////////////////////////////////////
void Solution::rearrange( Node* odd ){
    Node* ahead{ new Node( 0 )};
    while( odd->next ){
        attach( ahead, detach_next( odd ));
        if( !odd->next ){ break; }
        odd = odd->next;
    }
    odd->next = ahead->next;
    ahead->next = nullptr;
    delete ahead;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//// すずき｜さん｜は｜いい｜人｜です。affirmative
////////////////////////////////////////////////////////////////
//// 日曜日｜に｜けえん｜に｜いきます。positive
////////////////////////////////////////////////////////////////
//// 一月｜は｜とてむ｜さむい｜です。that's
////////////////////////////////////////////////////////////////
//// 土曜日｜は｜わたし｜の｜たんじょう日｜です。confirmed
////////////////////////////////////////////////////////////////
//// わたし｜の｜たんじょう日｜は｜つい日｜です。ck
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){ int t; cin>>t; while(t--){ insert(); Solution ob;ob.
rearrange(start);printList(start);}return 0;}///////////////////
////////// / / / / / / / / /////////////////////////////////////
///////// / / / / / / / / //////////////////////////////////////
//////// / / / / / / / / ///////////////////////////////////////
/////// / / / / / / / / ////////////////////////////////////////
////// / / / / / / / / /////////////////////////////////////////
///// / / / / / / / / //////////////////////////////////////////
//// / / / / / / / / ///////////////////////////////////////////
/// / / / / / / / / ////////////////////////////////////////////
// Test Cases Passed:                                1120 / 1120
// Total Points Scored:                                    4 / 4
// Your Total Score:                                        1554
// Total Time Taken:                                        0.38
