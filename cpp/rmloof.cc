////////////////////////////////////////////////////////////////
// Remove loop in Linked List
// Medium Accuracy: 47.96% Submissions: 100k+ Points: 4
// Givn a linked list of N nods such that it may contain a loop.
// A loop here means tht the last node f the link list s conectd
// to the node at position X. If the link list does not have any
// loop, X = 0.
// Remove the loop from the linked list, if it is present.  
//////////////////////////////////////////////////////////////
# include <iostream> ///////////////////////////////////////// d
using namespace std; ///////////////////////////////////////// r
struct Node ////////////////////////////////////////////////// i
{ //////////////////////////////////////////////////////////// v
    int   data;/////////////////////////////////////////////// e
    Node* next;/////////////////////////////////////////////// r
    Node(int val)/////////////////////////////////////////////
    {///////////////////////////////////////////////////////// c
        data = val;/////////////////////////////////////////// o
        next = NULL;////////////////////////////////////////// d
    }///////////////////////////////////////////////////////// e
};////////////////////////////////////////////////////////////
void loopHere(Node* head, Node* tail, int position)/////////////
{///////////////////////////////////////////////////////////////
    if(position == 0) return;///////////////////////////////////
    Node* walk = head;//////////////////////////////////////////
    for(int i = 1; i < position; i++)///////////////////////////
        walk = walk->next;//////////////////////////////////////
    tail->next = walk;//////////////////////////////////////////
}///////////////////////////////////////////////////////////////
bool isLoop(Node* head)/////////////////////////////////////////
{///////////////////////////////////////////////////////////////
    if(!head) return false;/////////////////////////////////////
    Node* fast = head->next;////////////////////////////////////
    Node* slow = head;//////////////////////////////////////////
    while( fast != slow)////////////////////////////////////////
    {///////////////////////////////////////////////////////////
        if( !fast || !fast->next ) return false;////////////////
        fast = fast->next->next;////////////////////////////////
        slow = slow->next;//////////////////////////////////////
    }///////////////////////////////////////////////////////////
    return true;////////////////////////////////////////////////
}///////////////////////////////////////////////////////////////
int length(Node* head)//////////////////////////////////////////
{///////////////////////////////////////////////////////////////
    int ret = 0;////////////////////////////////////////////////
    while(head)/////////////////////////////////////////////////
    {///////////////////////////////////////////////////////////
        ret++;//////////////////////////////////////////////////
        head = head->next;//////////////////////////////////////
    }///////////////////////////////////////////////////////////
    return ret;/////////////////////////////////////////////////
}///////////////////////////////////////////////////////////////
class Solution//////////////////////////////////////////////////
{///////////////////////////////////////////////////////////////
public://///////////////////////////////////////////////////////
    void removeLoop(Node* head);////////////////////////////////
};//////////////////////////////////////////////////////////////
int main()//////////////////////////////////////////////////////
{///////////////////////////////////////////////////////////////
    int t;//////////////////////////////////////////////////////
    cin >> t;///////////////////////////////////////////////////
    while(t--)//////////////////////////////////////////////////
    {///////////////////////////////////////////////////////////
        int n, num;/////////////////////////////////////////////
        cin >> n;///////////////////////////////////////////////
        Node *head, *tail;//////////////////////////////////////
        cin >> num;/////////////////////////////////////////////
        head = tail = new Node(num);////////////////////////////
        for(int i = 0 ; i < n - 1 ; i++)////////////////////////
        {///////////////////////////////////////////////////////
            cin >> num;/////////////////////////////////////////
            tail->next = new Node(num);/////////////////////////
            tail = tail->next;//////////////////////////////////
        }///////////////////////////////////////////////////////
        int pos;////////////////////////////////////////////////
        cin >> pos;/////////////////////////////////////////////
        loopHere(head, tail, pos);//////////////////////////////
        Solution ob;////////////////////////////////////////////
        ob.removeLoop(head);////////////////////////////////////
        if(isLoop(head) || length(head)!=n)/////////////////////
            cout << "0\n";//////////////////////////////////////
        else////////////////////////////////////////////////////
            cout << "1\n";//////////////////////////////////////
    }///////////////////////////////////////////////////////////
    return 0;///////////////////////////////////////////////////
}///////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Why Floyd's Cycle Detection algorithm works?
// https://www.youtube.com/watch?v=HXNJSkh5kFo
// Test Cases Passed: 151 / 151
// Total Time Taken: 0.26 / 1.44
void detach( Node* head, Node* s ){
    if( head == s ){
        while( head != s->next ){
            s = s->next;
        }
    } else {
        while( head->next != s->next ){
            head = head->next;
            s = s->next;
        }
    }
    s->next = NULL;
}
void Solution::removeLoop( Node* head ){
////----////----////----\\\\,,,,````----////____````____,,,,----
    Node* f{ head };
    Node* s{ head };
    while( f and f->next ){
        s = s->next;
        f = f->next->next;
        if( s == f ) return detach( head, s );
    }    
}
////////////////////////////////////////////////////////////////
