// ////////////////////////////////////////////////////////////-
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ////////////////////////  //////////////////////////////////-
// \\\\\\\\\\\\\\\\\\\\\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ///////         ///            /////////////////////////////-
// \\\\\\\  \\\\\  \\\\\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ///////  /////  ////////  //////////////////////////////////-
// \\\\\\\         \\              \\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ///////  /////  //////////  ////////////////////////////////-
// \\\\\\\  \\\\\  \\\\\\\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ///////         //              ////////////////////////////-
// \\\\\\\  \\\\\\\\\\\\\\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ////////////////////  ////  ////////////////////////////////-
// \\\\\\\\\\\\\\\\\\\\\\  \\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// //////////////////////////  ////////////////////////////////-
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ////////////////////////////////////////////////////////////-
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
// ////////////////////////////////////////////////////////////-
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\=
# include <vector>
# include <string>
# include <queue>
# include <iostream>
# include <sstream>
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
struct Node{int data;struct Node*left;struct Node*right;};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node*newNode(int val){Node*temp=new Node;temp->data=val;temp->left
=NULL;temp->right=NULL;return temp;}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node*buildTree(string str){if(str.length()==0||str[0]=='N')return 
NULL;vector<string>ip;istringstream iss(str);for(string str;iss>>
str;)ip.push_back(str);Node*root=newNode(stoi(ip[0]));queue<Node*>
queue;queue.push(root);int i=1;while(!queue.empty()&&i<ip.size()){
Node*currNode=queue.front();queue.pop();string currVal=ip[i];if
(currVal!="N"){currNode->left=newNode(stoi(currVal));queue.push
(currNode->left);}i++;if(i>=ip.size())break;currVal=ip[i];if(currVal
!="N"){currNode->right=newNode(stoi(currVal));queue.push(currNode
->right);}i++;}return root;}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int kthAncestor(Node*root,int k,int node);
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){int t;cin>>t;while(t--){int k,node;cin>>k>>node;cin.
ignore();string s;getline(cin,s);Node*root=buildTree(s);cout<<
kthAncestor(root,k,node)<<endl;}}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Dfs {
private:
    int data;
    int k;
    vector<int> ancs;
public:
    Dfs( int data, int k ):
        data( data ),
        k( k )
    {}
    void travel( Node* root );
};
void Dfs::travel( Node* root ){
    if( !root ) return;
    if( root->data == data ){
        throw ancs.size() < k ? -1 : ancs[ ancs.size() - k ];
    }
    ancs.push_back( root->data );
    travel( root->left );
    travel( root->right );
    ancs.pop_back();
}
////////////////////////////////////////////////////////////////
// ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら　ら
// わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ　わ
// れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ　れ
// を　を　を　を　を　を　を　を　を　を　を　を　を　を　を　を　を　を　を
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int kthAncestor( Node* root, int k, int data ){
    Dfs dfs( data, k );
    try {
        dfs.travel( root );
    } catch( int ancs ){
        return ancs;
    }
    return {};
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                1120 / 1120
// Total Points Scored:                                    4 / 4
// Your Total Score:                                        1310
// Total Time Taken:                                        0.52

