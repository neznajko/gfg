////////////////////////////////////////////////////////////////
// Arrange Consonants and Vowels
////////////////////////////////////////////////////////////////
// Given a singly linked list having n nodes containing english
// alphabets ('a'-'z'). Rearrange the linked list in such a way
// that all the vowels come before the consonants while
//  maintaining the order of their arrival
////////////////////////////////////////////////////////////////
// Input: n = 9
//        linked list: a -> b -> c -> d -> e -> f -> g -> h -> i 
// Output: a -> e -> i -> b -> c -> d -> f -> g -> h
////////////////////////////////////////////////////////////////
// Input: n = 8
//        linked list: a -> b -> a -> b -> d -> e -> e -> d 
// Output: a -> a -> e -> e -> b -> b -> d -> d
////////////////////////////////////////////////////////////////
// Expected Time Complexity: O(n)
// Expected Auxiliary Space: O(1)
////////////////////////////////////////////////////////////////
// 1 <= n <= 10^4
// 'a' <= elements of linked list <= 'z'
////////////////////////////////////////////////////////////////
# include <iostream>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
struct Node { char data; struct Node* next; Node( int x  ){ data
= x; next = NULL; }};///////////////////////////////////////////
////////////////////////////////////////////////////////////////
void printlist( Node* head ){ if( head == NULL ) return; while (
head != NULL ){ cout << head->data  << " "; head = head->next; }
cout << endl;}//////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void append(  Node** headRef, char data  ){ Node* new_node = new 
Node(  data ); Node* last =  *headRef; if(  *headRef  == NULL ){
*headRef =  new_node; return; } while( last->next != NULL ) last 
= last->next; last->next = new_node; }//////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 1. a 今八時ですよ
//      Es ist jetzt acht Uhr, weißt du
// 2. a 喫茶店でコーヒーを飲みませんか
//      Kaffee im Café trinken
// 3. a 家に帰ります
//      nach Hause gehen
//    c 勉強します
//      Ich werde lernen
// 4. b 喫茶店で日本語話します
//      im Café Japanisch sprechen
//    c 明日学校で昼ご飯を食べませんか
//      Wollen wir morgen in der Schule Mittagessen?
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
bool is_vowel( char c )
{
    switch( c ){
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u': return true;
    default: return false;
    }
}
////////////////////////////////////////////////////////////////
bool is_consonant( char c )
{
    return !is_vowel( c );
}
////////////////////////////////////////////////////////////////
class Solution {
public:
    Node* arrangeCV( Node* head );
};
////////////////////////////////////////////////////////////////
# define key( P ) (( P )->data )
////////////////////////////////////////////////////////////////
Node* prev_to_fst_consonant( Node* ahead )
{
    Node* p = ahead;
    while( p->next ){
        if( is_consonant( key( p->next ))) break;
        p = p->next;
    }
    return p;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node* detach_next( Node* p )
{
    Node* q = p->next;
    p->next = q->next;
    q->next = NULL;
    return q;
}
////////////////////////////////////////////////////////////////
Node* insert_coin( Node* tail, Node* p )
{
    p->next = tail->next;
    tail->next = p;
    return p;
}
////////////////////////////////////////////////////////////////
Node* Solution::arrangeCV( Node* head )
{
    Node ahead( 0 );
    ahead.next = head;
    Node* tail = prev_to_fst_consonant( &ahead );
    if( tail->next == NULL ) return head;
    Node* p = tail->next;
    while( p->next ){
        if( is_vowel( key( p->next ))){
            Node* q = detach_next( p );
            tail = insert_coin( tail, q );
        } else {
            p = p->next;
        }
    }
    return ahead.next;
}
////////////////////////////////////////////////////////////////
int main() { int T;  cin >> T;  while( T-- ){  int n;  char tmp;
Node* head = NULL; cin >> n; while( n-- ){ cin >> tmp; append( &
head,  tmp ); } Solution obj;  head  =  obj.arrangeCV(  head  );
printlist( head ); }}///////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                1120 / 1120
// Points Scored:                                          4 / 4
// Your Total Score:                                        1842 
// Time Taken:                                              0.16
