////////////////////////////////////////////////////////////////
//############################################################//
//############################################################//
//############################################################//
//############################################################//
//############################..##############################//
//#######..#################......############################//
//////     ///////////////          ////////////////////////////
//######.....###########..........############################//
//######.....#########..........##############################//
//########.....#####.............................#############//
//########..######..........#.....................############//
//#####..#######..........####################################//
//##.....#########......##....................################//
//####.....#########..####.....................###############//
//####.....###############.....#...............###############//
//######.....#############.....###.....###.....###############//
////////  ////////////////     ///     ///     /////////////////
/////////////////////                               ////////////
/////////////////////                               ////////////
/////////  ///////////                             /////////////
/////////     ////////////     ///     ///     /////////////////
////////     /////////////     ///     ///     /////////////////
//######.....#############.....#.........#.........###########//
///////     //////////////                          ////////////
///////     ///////////////                         ////////////
//////     ///////////////////////////////     /////////////////
//////     ///////////////////////////////     /////////////////
/////     /////////////////////////////////    /////////////////
////////  //////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 星 の「海」[ Океан ] от звезди
////////////////////////////////////////////////////////////////
// Palindromic Partitioning
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// G  i  v  e  n a string s, a partitioning of t h e string is a
// palindrome partitioning if every sub-string o f the partition
// is a palindrome. D e t e r m i n e the fewest cuts needed for
// palindrome partitioning of the given string
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Input: s = "geek" 
// Output: 2 
// Explanation: We need to make minimum 2 cuts, i.e., g | ee | k
////////////////////////////////////////////////////////////////
// 1 ≤ |s| ≤ 10³
// s contain lowercase letters only
////////////////////////////////////////////////////////////////
// Time Complexity: O(n²)
// Auxiliary Space: O(n²)
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <string>
# include <iostream>
# include <vector>
# include <utility>
# include <queue>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
// しゅくだい　宿題　homework
// 食べ物　たべもの　food
// 誕生日　たんじょうび　birthday
// テスト　test
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
template <typename T>
ostream& operator <<( ostream& _, const vector <T> &vec ){
    _ << "[";
    string delim = "";
    for( const auto& value: vec ){
        _ << delim << ( int )value;
        delim = " ";
    }
    return _ << "]";
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// <> 2.1.44*: Determine the steady-s t a t e velocity of a body
// located on an i n c l i n e d plane that changes its velocity
// direction and t  h  e  n t o the opposite direction with high
// frequency. The direction of t h e plane's motion is shown i n
// the figure. T h e coefficient o f friction is μ, the angle of
// inclination of the plane is α, tg α < μ
//
//                         u        tg β = u/v
//        -u       +u     <---+---> 
//       <--       -->       `|`           .|.     
//       _ _ _ _ _ _        ` |β`         . | . 
//      /           /      `  |  `       .  |  .
//     /  __ b ody /      `   V v `     .   |F  . F = 2fcosβ
//    /  /_/\     /                     \   |   /
//   /   \_\/    /                       \  |  /   
//  /           / α                     f \β| / f  
// /_ _ _ _ _ _/. . . .                    \|/
//                                           
// This we've seen in the previous problems t h e force decrease
// by factor of cosβ from 2f to 2fcosβ, h e r e we calculate the
// sum f o r c e in two c o n g e s t i v e moments. I n balance
// mgsinα = fcosβ = μmgcosαcosβ, z o tgα = μcosβ = μ/√(1 + tg²β),
// zo √(1 + tg²β) = μ/tgα, tg²β = μ²/tg²α - 1 = (μ² - tg²α)/tg²α
// tgβ = √(μ² - tg²α)/tgα = u/v, that is v = utgα/√(μ² - tg²α) «
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Solution {
public:
    int palPartition( string& s ){
        build( move( s ));
        return bfs();
    }
private:
    enum { NONE, NOPE, OKAY };
    using flag_t = char;
    using matrix_t = vector <vector <flag_t>>;
    using adj_t = vector <vector <int>>;
    int n;
    string s;
    matrix_t h;
    adj_t adj;
    //
    flag_t dp( int i, int j ){
        if( i > j ) return OKAY;
        if( h[i][j] != NONE ) return h[i][j];
        dp( i + 1, j );
        dp( i, j - 1 );
        if( s[i] == s[j] ){
            return h[i][j] = dp( i + 1, j - 1 );
        }
        return h[i][j] = NOPE;
    }
    void build_h() {
        h = matrix_t( n, vector <flag_t> ( n, NONE ));
        dp( 0, n - 1 );
    }
    void build_adj() {
        adj = adj_t( n );
        for( int i = 0; i < n; ++i ){
            for( int j = i; j < n; ++j ){
                if( h[i][j] == OKAY ){
                    adj[i].push_back( j + 1 );
                }
            }
        }
    }
    void build( string&& s ){
        n = s.size();
        this->s = move( s );
        build_h();
        build_adj();
    }
    void debug() {
        cout << s << endl;
        for( int i = 0; i < n; ++i ){
            cout << h[i] << endl;
        }
        for( int i = 0; i < n; ++i ){
            cout << adj[i] << endl;
        }
    }
    int bfs() {
        vector <bool> vstd( n );
        queue <pair <int,int>> q; // offset, nfcuts
        q.push({ 0, 0 });
        vstd[0] = true;

        while( !q.empty()){
            auto [i, nfcuts] = q.front();
            q.pop();

            for( int j: adj[i] ){
                if( j == n ) return nfcuts;
                if( !vstd[j] ){
                    vstd[j] = true;
                    q.push({ j, nfcuts + 1 });
                }
            }
        }
        return {};
    }
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 13. [M2S] Given that x is a positive real number a n d n is a
// positive integer, prove the inequality ⁿ√(1 + x) — 1 ≤ x/n
//
// T  h  e t    r    i    c    k is to set h = x/n, then we have:
// ⁿ√(1 + nh) — 1 ≤ h, ⁿ√(1 + nh) ≤ 1 + h, 1 + nh ≤ (1 + h)ⁿ
// Now we c a n expand the right side into binomial coefficients:
// (1 + h)ⁿ = Σ{i=0,n}C(n,i)hⁱ = 1 + nh + Σ{i=2,n}C(n,i)hⁱ     «
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() {
    string s;
    cin >> s;
    cout << Solution().palPartition( s ) << endl;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                1111 / 1111
// Points Scored:                                          8 / 8
// Your Total Score:                                        1950 
// Time Taken:                                              0.17

