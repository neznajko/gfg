////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Segregate even and odd nodes in a Linked List
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Given a link list of size N, modify the list such that all
// the even numbers appear before all the odd numbers in the
// modified list. The order of appearance of numbers within each
// segregation should be same as that in the original list
//
// NOTE: Don't create a new linked list, instead rearrange the
// provided one.
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Input:  N = 7
// Link List: 17 -> 15 -> 8 -> 9 -> 2 -> 4 -> 6 -> NULL
// Output: 8 2 4 6 17 15 9
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Expected Time Complexity: O(N)
// Expected Auxiliary Space: O(1)
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 1 ≤ N ≤ 10^5
// 1 ≤ Each element of the list ≤ 10^5
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
struct Node { int data; struct Node* next; Node( int x ){ data = 
x; next = NULL;}};
////////////////////////////////////////////////////////////////
void printList( Node* node ){ while ( node != NULL ){ cout << 
node->data <<" "; node = node->next; } cout<<"\n";} 
////////////////////////////////////////////////////////////////
class Solution {
public:
	Node* divide( int n, Node* p );
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline bool is_odd( int a ){ return a & 1; }
inline bool is_evn( int b ){ return !is_odd( b ); }
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node* find_last_even( Node* p )
{
	Node* last_even = NULL;
	while( p != NULL ){
		if( is_evn( p->data )){
			last_even = p;
		}
		p = p->next;
	}
	return last_even;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node* detach_next( Node* p )
{
	Node* q = p->next;
	p->next = q->next;
	q->next = NULL;
	return q;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void insert( Node* q, Node* tail )
{
	q->next = tail->next;
	tail->next = q;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node* Solution::divide( int n, Node* p )
{
	Node ahead( 0 );
	ahead.next = p;
	p = &ahead;
	Node* last_even = find_last_even( p->next );
	if( last_even == NULL ) return ahead.next;
	Node* tail = last_even;
	while( p != last_even ){
		if( is_odd( p->next->data )){
			Node* q = detach_next( p );
			insert( q, tail );
			tail = q;
		} else {
			p = p->next;
		}
	}
	return ahead.next;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() { int t; cin >> t; while( t-- ){ int N; cin >> N; int
data; cin >> data; struct Node* head = new Node( data ); struct
Node* tail = head; for (int i = 0; i < N-1; ++i) { cin >> data;
tail->next = new Node(data); tail = tail->next;} Solution ob;
Node* ans = ob.divide(N, head); printList(ans);}}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                1212 / 1212
// Points Scored:                                          4 / 4
// Your Total Score:                                        1834 
// Time Taken:                                              0.26
