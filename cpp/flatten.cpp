//////////////////////////////////////////////////////////////// lll brown
///////////////llllllllllllllllllllll/////////////////////////// """ violet
///////////////llllllllllllllllllllll/////////////////////////// &&& red
///////////////llllllllllllllllllllll""""""""""""""///////////// '_' dark red
///////////////lllllllllllllll   llll""""""""""""""///////////// /// ?
///////////////llll                         """""""/////////////
///////////////llllllllllllllllllllll""""""""""""""/////////////
///////////////lllllllll               """"""""""""/////////////
///////////////lllllllll  lllllllllll  """"""""""""/////////////
////////////////////////  ///""""""""  """"""""""""/////////////
////////&&&&&&&&&&&&&&&&                 """"""""""/////////////
////////&&&&&&&&&&&&&&&&&&&&&""""""""""""""""""""""/////////////
////////&&&&&&&&&&&                         """""""/////////////
////////&&&&&&&&&&&   &&&&&&&&&&&////////   ////////////////////
////////&&&&&&&&&&&   &&               //   ////////////////////
////////&&&&&&&&&&&   &&   &&&&&&_'_   _'   '_'_'_'_'_'/////////
///////////////////   //   ////'_'_'   '_   _'_'_'_'_'_/////////
///////////////////   //               _'   '_'_'_'_'_'/////////
///////////////////   //   ////'_'_'_'_'_   _'_'_'_'_'_/////////
///////////////////////////////_'_'_'_'_'_'_'_'_'_'_'_'/////////
///////////////////////////////'_'_'_'_'_'_'_'_'_'_'_'_/////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Flattening a Linked List, 高い、たか.い、ta-ka-i, expensive
////////////////////////////////////////////////////////////////
// Given a Linked List of size N, where every node represents a
// sub-linked-list and contains two pointers:
// ( i) a next pointer to the next node
// (ii) a bottom pointer to a linked list where this node is 
//      head
// Each of the sub-linked-list is in sorted order. Flatten the 
// Link List such that all the nodes appear in a single level 
// while maintaining the sorted order.
// Note: The flattened list will be printed using the bottom 
// pointer instead of next pointer.
////////////////////////////////////////////////////////////////
// Input: 5 -> 10 -> 19 -> 28
//        |    |     |     |
//        7    20    22    35
//        |          |     |
//        8          50    40
//        |                |
//        30               45
//
// Output: 5->7->8->10->19->20->22->28->30->35->40->45->50
// Explanation: ...
////////////////////////////////////////////////////////////////
// Expected Time Complexity: O(N*M)
// Expected Auxiliary Space: O(1)
////////////////////////////////////////////////////////////////
// 0 <= N <= 50
// 1 <= Mi <= 20
// 1 <= Element of linked list <= 10^3
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////             |             | -----_-----_-------------
//// schwach     | weak        | D i e n u r s c h w a c h 
////         nur | o n l y     | ---------------------_-----------
//// ausgeprägte | distinctive | a u s g e p r á g t e T a i l l e
//// t a i l l e | w a i s t   | -----_-------_---------------
//// s c h m a l | n a r r o w | u n d s e i n s c h m a l e s
//// b e c k e n | p e l v i s | -----------_-----------
//// l a s s e n |      l e t  | B e c k e n l a s s e n
////   u m r i ß | outline     | ---------_---------------------------
//// s t e h e n | s t a n d   | S e i n e s i l h o u e t t i e r t e
////   k e i l   | w e d g e   | -----------------_-----_-------
//// erscheinen  | to appear   | U m r i ß f o r m a l s e i n e
////             |             | -----_-----_-----------_---------------
////             |             | a u f d e r S p i t z e s t e h e n d e
////             |             | ---------------_-------------------_-
////             |             | K e i l f o r m e r s c h e i n e n .
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
# include <iostream>
////////////////////////////////////////////////////////////////
struct Node{ int data;struct Node* next;struct Node*bottom;Node(
int x){data=x;next=NULL;bottom=NULL;}};/////////////////////////
////////////////////////////////////////////////////////////////
void printList(Node*Node){ while(Node!=NULL){printf("%d ",Node->
data);Node=Node->bottom;}}//////////////////////////////////////
////////////////////////////////////////////////////////////////
//// heute -  today                8. Kommst du auf meine Party?
//// schade - it's pity!           öö Wann?
////                               8] Am Samstag Abent.
////                               öò Shade das geht nicht.
////                               8[ ..
////                               öò Am Samstag gehe ich in die 
//////////////////////////////////////////////////////////////// D,
//////////////////////////////////////////////////////////////// I` 
//////////////////////////////////////////////////////////////// S`
//////////////////////////////////////////////////////////////// C,
//////////////////////////////////////////////////////////////// O 
////////////////////////////////////////////////////////////////  `
//////////////////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# define key(  P ) ( P )->data
# define bot(  P ) ( P )->bottom
# define next( P ) ( P )->next
////////////////////////////////////////////////////////////////
Node* ahead{ new Node( 0 )};
////////////////////////////////////////////////////////////////
class Solution {
public:
    Node* flatten( Node* root );
};
////////////////////////////////////////////////////////////////
Node* find( int key, Node* h ){
    while( bot( h ) and key( bot( h )) < key ){
        h = bot( h );
    }
    return h;
}
////////////////////////////////////////////////////////////////
void insert( Node* p, Node* h ){
    bot( p ) = bot( h );
    bot( h ) = p;
}
////////////////////////////////////////////////////////////////
void merge( Node* p ){
    Node* h{ ahead };
    while( p ){
        Node* b{ bot( p )};
        h = find( key( p ), h );
        insert( p, h );
        h = p;
        p = b;
    }
}
////////////////////////////////////////////////////////////////
Node* Solution::flatten( Node* root ){
    bot( ahead ) = root;
    Node* n{ next( root )};
    while( n ){
        merge( n );
        n = next( n );
    }
    return bot( ahead );
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// あしたは｜一がつ｜みつ日｜です。( xv )
// a shi ta wa i chi ga tsu mi k ka de su
// Tomorrow is January 3rd.  
// 
// あなた｜の｜きょうだい｜は｜なん人｜いまですか。( v )
// anata no kyoodai wa nannin imadesuka
// How many siblings do you have? 
//
// あした｜わたし｜は｜一人｜で｜えいが｜みます。( v )
// ashita       wa      de    mimasu
//       watashi  hitori  eiga
// Tomorrow   going  watch movie  myself
//         I'm     to     a     by      .
//
// わたし｜わ｜にほん人｜です。( v )
// watashi wa nihonjin desu
// I'm Japanese.
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(void){ int t;cin>>t;while(t--){ int n,m,flag=1,flag1=1;
struct Node*temp=NULL;struct Node*head=NULL;struct Node*pre=NULL
;struct Node*tempB=NULL;struct Node*preB=NULL; cin>>n; int*work=
new int[n];for(int i=0;i<n;i++)cin>>work[i];for(int i=0;i<n;i++)
{m=work[i];--m;int data;scanf_s("%d",&data);temp=new Node(data);
temp->next=NULL; temp->bottom=NULL; if(flag){head=temp;pre=temp;
flag=0;flag1=1;}else{pre->next=temp;pre=temp;flag1=1;}for(int j=
0;j<m;j++){int temp_data;scanf_s("%d",&temp_data);tempB=new Node
(temp_data); if(flag1){temp->bottom=tempB; preB=tempB; flag1=0;}
else{ preB->bottom=tempB;preB=tempB;}}} Node*fun=head;Node*fun2=
head;Solution ob;Node*root=ob.flatten(head);printList(root);cout
<<endl;}}///////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Listen .. oo xo öò ÖÒ
////////////////////////////////////////////////////////////////
// a) すきゃき、pot( ￥3000 )
// b) うどん、noodle( ￥600 )
// c) てんぷら、deep fry( ￥1200 )
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                    80 / 80
// Total Points Scored:                                    4 / 4
// Your Total Score:                                        1530
// Total Time Taken:                                        0.01
