////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//     .........------===#######################################
//    ........-----===############    //////////////////////////
// ...........-----===#############   //////////////////////////
//    .......-----===##############   //////////////////////////
// .........-----===#######...#####   //////////////////////////
// .......-----===######...########   //////////////////////////
//  ...------===#####...###########   //////////////////////////
//...------===####,,,##############   //////////////////////////
//..-----===###...,,,##                            /////////////
//----===###...###,,,#############     /////////////////////////
//-===###...######,,,############       ////////////////////////
//=####.##########,,,##########   /   /   //////////////////////
//################,,,########   ///   ///   ////////////////////
//############||||,,,||||//   /////   /////   //////////////////
//////////////||||,,,||||   ///////   ///////   ///////////////t
//////////////||||,,,||   /////////   /////////   /////////////o
//////////////||||,,,||||//////////   //////////////////////////
//////////////||||,,,||||//////////   /////////////////////////r
//////////////||||,,|||||//////////  //////////////////////////e
//////////////||||,||||||////////// ///////////////////////////s
//////////////||||,||||||//////////////////////////////////////t
//////////////|||||||||||///////// /////////////////////////////
//////////////|||||||||||///////////////////////////////////////
//////////////|||||||||||///////////////////////////////////////
// Solve the Sudoku, 休、やす（む）
////////////////////////////////////////////////////////////////
// Given an incomplete Sudoku configuration in terms of a 9 x 9  
// 2D square matrix (grid[][]), the task is to find a solved 
// Sudoku. For simplicity, you may assume that there will be 
// only one unique solution.
////////////////////////////////////////////////////////////////
// A sudoku solution must satisfy all of the following rules:
////////////////////////////////////////////////////////////////
// Each of the digits 1-9 must occur exactly once in each row.
// Each of the digits 1-9 must occur exactly once in each colmn.
// Each of the digits 1-9 must occur exactly once in each of the
// 9 3x3 sub-boxes of the grid.
////////////////////////////////////////////////////////////////
// Zeros in the grid indicates blanks, which are to be filled 
// with some number between 1-9. You can not replace the element 
// in the cell which is not blank.
////////////////////////////////////////////////////////////////
// Input: grid[][] = [[3 0 6 5 0 8 4 0 0],
//                    [5 2 0 0 0 0 0 0 0],
//                    [0 8 7 0 0 0 0 3 1],
//                    [0 0 3 0 1 0 0 8 0],
//                    [9 0 0 8 6 3 0 0 5],
//                    [0 5 0 0 9 0 6 0 0],
//                    [1 3 0 0 0 0 2 5 0],
//                    [0 0 0 0 0 0 0 7 4],
//                    [0 0 5 2 0 6 3 0 0]]
// Output: True
//         3 1 6 5 7 8 4 9 2
//         5 2 9 1 3 4 7 6 8
//         4 8 7 6 2 9 5 3 1
//         2 6 3 4 1 5 9 8 7
//         9 7 4 8 6 3 1 2 5
//         8 5 1 7 9 2 6 4 3
//         1 3 8 9 4 7 2 5 6
//         6 9 2 3 5 1 8 7 4
//         7 4 5 2 8 6 3 1 9
// Explanation: There exists a valid Sudoku for the input grid, 
// which is shown in output.
////////////////////////////////////////////////////////////////
// Input: grid[][] = [[3 6 6 5 0 8 4 0 0],
//                    [5 2 0 0 0 0 0 0 0],
//                    [0 8 7 0 0 0 0 3 1],
//                    [0 0 3 0 1 0 0 8 0],
//                    [9 0 0 8 6 3 0 0 5],
//                    [0 5 0 0 9 0 6 0 0],
//                    [1 3 0 0 0 0 2 5 0],
//                    [0 0 0 0 0 0 0 7 4],
//                    [0 0 5 2 0 6 3 0 0]]
// Output: False
// Explanation: There does not exists a valid Sudoku for the 
// input grid, since there are two 6s in the first row. Which 
// cannot be replaced.
////////////////////////////////////////////////////////////////
// Expected Time Complexity: O(9^N*N).
// Expected Auxiliary Space: O(N*N).
////////////////////////////////////////////////////////////////
// 0 ≤ grid[i][j] ≤ 9
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
# include <iostream>
# include <vector>
////////////////////////////////////////////////////////////////
# define N 9  
# define S 3
////////////////////////////////////////////////////////////////
typedef int grid_t[ N ][ N ];
typedef vector<int> vec_t;
typedef vector<vec_t> mat_t;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
/// Der spanische Künstleranatom Christomo Martinez (l. Mitte)
/// baut den Vitruvmann mit Knochen- und Muskelangaben aus, ..
////////////////////////////////////////////////////////////////
/// künstler - artist
/// baut - build
/// knochen - bone
/// angaben - information
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Solution {
private:
    static void debug( const mat_t& mat, bool fat=true );
    mat_t _sdk = mat_t( N, vec_t( N ));
    mat_t _hrz = mat_t( N, vec_t( N + 1 ));
    mat_t _vrt = mat_t( N, vec_t( N + 1 ));
    mat_t _sec = mat_t( N, vec_t( N + 1 )); // sector
    bool setup( const grid_t& grid );
    void dfs( int i, int j );
public:
    bool SolveSudoku( const grid_t& grid );
    // printGrid(): Takes a grid as its argument and prints the 
    // 81 numbers of the solved Sudoku in a single line with 
    // space separation. Do not give a new line character after 
    // printing the grid.
    void printGrid( const grid_t& grid );
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
/////////////////////////////////////////\\\\\//////////////////
//////////////////////////////////////////\\\\\/////////////////
// &:{ Bitte schön?                        \\\\\
// `C:, Ich hätte gern sechs Eier bitte.    \\\\\
// &:{ Außerdem noch etwas?                  \\\\\
// *C:' Ja, ein Liter Milch, bitte.           \\\\\
// .C:" Was macht das zusammen?                \\\\\
// &:{ Zwei Euro zwanzig bitte.                 \\\\\
/////////////////////////////////////////////////\\\\\//////////
//////////////////////////////////////////////////\\\\\/////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void Solution::debug( const mat_t& mat, bool fat ){
    int m = mat.size();
    int n = mat[0].size();
    for( int i = 0; i < m; ++i ){
        for( int j = 0; j < n; ++j ){
            cout << mat[i][j] << ' ';
        }
        if( fat ){ 
            cout << endl;
        }
    }
    if( fat ){
        cout << "=" << endl;
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int sector_offset( int i, int j ){
    return i / S * S + j / S;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
bool Solution::setup( const grid_t& grid ){
    for( int i = 0; i < N; ++i ){
        for( int j = 0; j < N; ++j ){
            int k = grid[i][j];
            if( k == 0 ) continue;
            int s = sector_offset( i, j );
            if( _hrz[i][k]++ ) return false;
            if( _vrt[j][k]++ ) return false;
            if( _sec[s][k]++ ) return false;
            _sdk[i][j] = k;
        }
    }
    return true;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void Solution::dfs( int i, int j ){
    if( i >= N ){
        throw( "Volley" );
    }
    if( j >= N ){
        dfs( i + 1, 0 );
    } else {
        if( _sdk[i][j] > 0 ){
            dfs( i, j + 1 );
        } else {
            int s = sector_offset( i, j );
            for( int k = N; k > 0; --k ){
                if( _hrz[i][k] ) continue;
                if( _vrt[j][k] ) continue;
                if( _sec[s][k] ) continue;
                _sdk[i][j] = k;
                _hrz[i][k] = 1;
                _vrt[j][k] = 1;
                _sec[s][k] = 1;
                dfs( i, j + 1 );
                _sdk[i][j] = 0;
                _hrz[i][k] = 0;
                _vrt[j][k] = 0;
                _sec[s][k] = 0;
            }
        }
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// I bought this book on Sunday. 
// nichiyoobi ni kono hon wo kaimashita 
// 日曜日｜に｜この｜ほん｜を｜かいました。
// kau かう- buy
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
bool Solution::SolveSudoku( const grid_t& grid ){
    if(! setup( grid )){
        return false;
    }
    if( 1 ){
        try {
            dfs( 0, 0 );
        } catch( ... ){
            return true;
        }
    }
    return false;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void Solution::printGrid( const grid_t& grid ){
    debug( _sdk, false );
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){int t;cin>>t;while(t--){int grid[N][N];for(int i=0;i<
9;i++)for(int j=0;j<9;j++)cin>>grid[ i ][ j ];Solution ob;if(ob.
SolveSudoku( grid ) == true ) ob.printGrid( grid ); else cout <<
"No solution exists";cout<<endl;}}//////////////////////////////
////////////////////////////////////////////////////////////////
// watch 12,600 / tokee wa ichimannisenroppyaku en desu
// とけい｜は｜いちまんにせんろっぴゃく｜えん｜です。
////////////////////////////////////////////////////////////////
// bag 4,200 \ kaban wa yonsennihyaku en desu
// かばん｜は｜よんせんにひゃく｜えん｜です。
////////////////////////////////////////////////////////////////
// pen 315 \ pen wa sanbyakujyugo en desu
// ペン｜は｜さんびゃくじゅうご｜えん｜です。
////////////////////////////////////////////////////////////////
// book 2,100 / hon wa nisenhyaku en desu
// ほん｜は｜にせんひゃく｜えん｜です。
////////////////////////////////////////////////////////////////
// hat 1,800 booshi wa senhappyaku en desu
// ぼうし｜は｜せんはっぴゃく｜えん｜です。
////////////////////////////////////////////////////////////////
// jeans 7,350 jiinzu wa nanasensanbyakugojuy en desu
// ジーンズ｜は｜ははせんさんびゃくごじゅう｜えん｜です。
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                  150 / 150
// Total Points Scored:                                    8 / 8
// Your Total Score:                                        1606
// Total Time Taken:                                        0.03
