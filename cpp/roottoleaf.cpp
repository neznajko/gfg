//////////////////////////////////////////////////////////////// 強
////////////////////////////////////////////////////////////////
////########################################################//// キ ki
////########################################################//// ヨ yo
////#####                                     ##############//// ウ  u
////#####  @@@@@@@@@@@@@@@@ %%%%%%%%%%%%%%%%  ##############////
////#####  @@@          @@@ %%%   %%%%%%%%%f  ##############//// forte
////#####  @@@@@@@@@@   @@@ %%   %%%%   %%%%  ##############////
////#####  @@@@@@@@@@   @@@ %            %%u  ##############//// сильний
////#####  @@@         @@@@ %%%%%%   %%   %%  ##############////
////#####  @@@@   @@@@@@@@@ %%%%%%   %%%%%%s  ##############//// fuerte
////#####  @@@@   @@@@@@@@@ %             %%  ##############////
////#####  /////         // =   ==   ==   =i  ##############//// forte
////#####  ///////////   // =             ==  ##############////
////#####  ///////////   // ======   ======g  ##############//// stark
////#####  ///////////   // ======   =   ===  ##############////
////#####  /////   ///   // =             ==  ##############////
////#####  //////       /// ============   =  ##############////
////#####  //////////////// ================  ##############////
////#####                                     ##############////
////##### strong ###########################################////
////########################################################////
////########################################################////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Root to Leaf Paths
////////////////////////////////////////////////////////////////
// Given a Binary Tree of nodes, you need to find all the
// possible paths from the root node to all the leaf nodes of
// the binary tree
////////////////////////////////////////////////////////////////
// Input: 1
//       / \
//      2   3
// Output: 
// 1 2 
// 1 3 
// Explanation: All possible paths: 1->2
//                                  1->3
////////////////////////////////////////////////////////////////
// Input:  10
//        /  \
//       /    \
//      20    30
//     /  \
//    40  60
// Output: 10 20 40 
//         10 20 60 
//         10 30 
////////////////////////////////////////////////////////////////
// Expected Time Complexity: O(n)
// Expected Auxiliary Space: O(height of the tree)
////////////////////////////////////////////////////////////////
// 1<=n<=10^4
////////////////////////////////////////////////////////////////
# include <string>
# include <vector>
# include <sstream>
# include <queue>
# include <iostream>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
struct Node{int data;struct Node*left;struct Node*right;Node(int
val){data=val;left=right=NULL;}};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node*buildTree(string str){if(str.length()==0||str[0]=='N')
return NULL;vector<string> ip;istringstream iss(str);for(string 
str;iss>>str;)ip.push_back(str);Node*root=new Node(stoi(ip[0]));
queue<Node*>queue;queue.push(root);int i=1;while(!queue.empty()
&&i<ip.size()){Node*currNode=queue.front();queue.pop();string
currVal=ip[i];if(currVal!="N"){currNode->left=new Node(stoi(
currVal));queue.push(currNode->left);}i++;if(i>=ip.size())break;
currVal=ip[i];if(currVal!="N"){currNode->right=new Node(stoi(
currVal));queue.push(currNode->right);}i++;}return root;}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
Node*inputTree(){string treeString;getline(cin,treeString);Node*
root=buildTree(treeString);return root;}
////////////////////////////////////////////////////////////////
void inorder(Node*root){if(root==NULL)return;inorder(root->left)
;cout<<root->data<<" ";inorder(root->right);}
////////////////////////////////////////////////////////////////
class Matrix{public:template<class T>static void input(vector<
vector<T>>&A,int n,int m){for(int i=0;i<n;i++){for(int j=0;j<m;j
++){scanf("%d ",&A[i][j]);}}}template <class T>static void print
(vector<vector<T>>&A){for(int i=0;i<A.size();i++){for(int j=0;j<
A[i].size();j++){cout<<A[i][j]<<" ";}cout<<endl;}}};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Solution {
private:
    vector <int> stack;
    vector <vector <int>> all_paths;
    //
    void dfs( Node* root );
public:
    vector <vector <int>> Paths( Node* root );
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main(){int t;scanf("%d ",&t);while(t--){Node*root=inputTree(
);Solution obj;vector<vector<int>>res=obj.Paths(root);Matrix::
print(res);}}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
vector <vector <int>> Solution::Paths( Node* root ){
    dfs( root );
    return all_paths;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void Solution::dfs( Node* root ){
    if(! root ) return;
    stack.push_back( root->data );
    if( root->left == root->right ){
        all_paths.push_back( stack );
    } else {
        dfs( root->left );
        dfs( root->right );
    }
    stack.pop_back();
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test Cases Passed:                                1115 / 1115
// Points Scored:                                          4 / 4
// Your Total Score:                                        1774 
// Time Taken:                                              0.09
