################################################################
# Find number of closed islands
################################################################
# Given a binar matri mat[][] o dimensions NxM suc that 1 denote
# ###########   ###   #######   ################   ###########  
# ###########   ###   #######   ################   ###########  
# ###########   ###   #######   ################   ###########  
# ########### ¥ ###   #######   ################   ###########  
# ###########   ###   #######   ################   ###########  
# ###########   ###   #######   ################   ###########  
# ###########   ### + #######   ################   ###########  
# ###########   ###   #######   ################   ###########  
# ###########   ###   ####### ƒ ################ ɦ ########### ʂ
# land and 0 denotes water. Find the number of closed islands in
# the given matrix.
################################################################
# A closed island is known as the group of 1s that is surrounded
# by only 0s on all the four sides (excluding diagonals). If any
# 1 is at the edges of the give matrix then it is not considered
# ###########################   ################################
# ###########################   ################################
# ###########################   ################################
# ###########################   ################################
# ########################### ɴ ################################
# ###########################   ################################
# ###########################   ################################
# as the part of the connected island as it is not surrounded by
# all 0's.
################################################################
# Example:        1
# Input:          N = 5, M = 8, mat[][] =
#              {{ 0, 0, 0, 0, 0, 0, 0, 1 }, 
#               { 0, 1, 1, 1, 1, 0, 0, 1 }, 
#               { 0, 1, 0, 1, 0, 0, 0, 1 }, 
#               { 0, 1, 1, 1, 1, 0, 1, 0 }, 
#               { 0, 0, 0, 0, 0, 0, 0, 1 }}
# Output:         2
# Explanation: {{ 0, 0, 0, 0, 0, 0, 0, 1 }, 
#               { 0, x, x, x, x, 0, 0, 1 }, 
#               { 0, x, 0, x, 0, 0, 0, 1 }, 
#               { 0, x, x, x, x, 0, x, 0 }, 
#               { 0, 0, 0, 0, 0, 0, 0, 1 }} 
###############################################################'
# Expected Time Complexity: O(N*M)
# Expected Auxiliary Space: O(N*M)
###############################################################=
# Constraints:
# 1 ≤ N,M ≤ 500
###############################################################_
################################################################
# compass ..
#         (-1, 0) ------+
#          ^            |
#          |            v
# (-1,-1) (±0,±0) (+1,+1)
# ^                     |
# |                     |
# +------ (+1,-1) <-----+
dr = (-1, 0),(+1,+1),(+1,-1),(-1,-1)
################################################################
# Test Cases Passed: 10054 / 10054                            öÒ
# Total Points Scored: 8 / 8       
# Your Total Score: 942            
# Total Time Taken: 1.41           
# Your Accuracy: 50%                                          
# Attempts No.: 2                  
################################################################
class Solution:
    ''''''
    def inbounds( self, i, j ):
        return( -1 < i          and
                     i < self.n and
                -1 < j          and
                     j < self.m )

    def explore( self, i, j ):
        self.mat[i][j] = 2 # mark as visited
        for di, dj in dr:
            i = i + di
            j = j + dj
            if( self.inbounds( i, j ) and
                self.mat[i][j] == 1 ):
                self.explore( i, j )

    def dfs_border_lands( self ):
        for i in range( self.n ):
            # 1 or ( m - 1 ), depending on i
            step = ( 1, self.m - 1 )[ i > 0 and i < self.n - 1 ]
            for j in range( 0, self.m, step ):
                if self.mat[i][j] == 1: self.explore( i, j )
    
    def closedIslands( self, mat, n, m ):
        if n <= 1 or m <= 1: return 0
        self.mat = mat
        self.n   = n
        self.m   = m
        self.dfs_border_lands()
        cc = 0
        for i in range( 1, self.n - 1 ):
            for j in range( 1, self.m - 1 ):
                if self.mat[i][j] == 1:
                    self.explore( i, j )
                    cc += 1
        return cc
###############################################################_
# log:
################################################################
print( Solution().closedIslands(
    [[ 0, 0, 0, 0, 0, 0, 0, 0 ],
     [ 0, 1, 1, 1, 1, 0, 0, 1 ],
     [ 0, 0, 0, 1, 1, 0, 0, 0 ],
     [ 1, 1, 0, 1, 1, 0, 1, 0 ],
     [ 0, 0, 0, 0, 0, 0, 0, 1 ]], 5, 8 ))
################################################################
########                                                ########
