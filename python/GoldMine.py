################################################################
# Gold Mine Problem
################################################################
################################################################
################################################################
################################################################
# Given a gold mine called M of nxm dimensions. Each field in this 
# mine contains a positive integer which is the amount of gold in 
# tons. Initially the miner can start from any row in the first 
# column. From a given cell, the miner can move:
# - to the cell diagonally up towards the right 
# - to the right
# - to the cell diagonally down towards the right
# Find out maximum amount of gold which he can collect.
################################################################
# Input: n = 3, m = 3, M = {{1, 3, 3},
#                           {2, 1, 4},
#                           {0, 6, 4}};
# Output: 12
# Explanation: The path is {(1,0) -> (2,1) -> (2,2)}
################################################################
# Input: n = 4, m = 4, M = {{1, 3, 1, 5},
#                           {2, 2, 4, 1},
#                           {5, 0, 2, 3},
#                           {0, 6, 1, 2}};
# Output: 16
# Explanation: The path is {(2,0) -> (3,1) -> (2,2) -> (2,3)} 
# or {(2,0) -> (1,1) -> (1,2) -> (0,3)}
################################################################
# Expected Time Complexity: O(n*m)
# Expected Auxiliary Space: O(n*m)
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
class Solution:
    def maxGold( self, n, m, M ):
        guards = [ 0 ]* m
        E = [ guards ] 
        E.extend( M )
        E.extend([ guards ])
        for j in reversed( range( m - 1 )):
            for i in range( 1, n + 1 ):
                E[i][j] += max( E[i-1][j+1], 
                                E[i  ][j+1], 
                                E[i+1][j+1])
        return max([ E[i][0] for i in range( 1, n + 1 )])
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
if __name__=='__main__':########################################
    t=int(input())##############################################
    for _ in range(t):##########################################
        n,m=[int(x) for x in input().split()]###################
        arr=[int(x) for x in input().split()]###################
        M=[]####################################################
        j=0#####################################################
        for i in range (n):#####################################
            M.append(arr[j:j+m])################################
            j=j+m###############################################
        ob=Solution()###########################################
        print(ob.maxGold(n,m,M))################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
# log: Algorithms are the steps that lead us from Nput to Output,
# so before finding our path we must know where is the start and 
# where is the finish but sometimes it helps thinking in reverse 
# instead of wondering how to achieve our goals we can visualize 
# ourselves crossing the finish line and ask how did we get here? 
# In the beginning of the problem we're fooled that we can start 
# from any position at the very first column but in actuality we 
#    start from the last column and work out our path in reverse.
# Test Cases Passed:                                   204 / 204
# Total Points Scored:                                     4 / 4
# Your Total Score:                                         1202
# Total Time Taken:                                         0.15
