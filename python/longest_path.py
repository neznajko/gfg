########################################################
########################################################
########################################################
########################################################
##########                                              
########## &&&&&&&&&&&&&////////////////////////////////
########## &&                      /////////////////////
# 01533010 &&&&&&&&&&&&'  _/////////////////////////////
# 56990481 &&&&&&&&&&&"  ,//////////////////////////////
# 03449349 &&&&&                ////////////////////////
# 64465431 &&&&&   &&&&&/////   ////////////////////////
# 01038574 55555   55555=====   ========================
# 75768844 55555                ========================
# 14656456 55555   55555=====   ========================
# 56565655 55555   55555=====   ========================
# 15465757 55555                ========================
# 35645656 5555555555555================================
# 46565654
# 76756756
# 23456453 
########################################################
########################################################
########################################################
########################################################
########################################################
########################################################
############################################################
# Sum of nodes on the longest path from root to leaf node ##
############################################################
########################################################
########################################################
#############################################################
# Given a binary tree of size N. Your task is to complete ###
# the function sumOfLongRootToLeafPath(), that find the sum #
# of all nodes on the longest path from root to leaf node. ##
# If two or more paths compete for the longest path, then ###
# the path having maximum sum of nodes is being considered. #
#############################################################
# Input: 4      Output: 13 #############################
#       / \ ############################################
#      /   \ ###########################################
#     2     5 ##########################################     
#    / \   / \ #########################################
#   7   1 3   2 ########################################
#       /      \ #######################################
#      6        1          4 2 5 7 1 3 2 N N 6 N N N N 1
########################################################
# Expected Time Complexity: O(N) #######################
# Expected Auxiliary Space: O(N) #######################
########################################################
######################################### 4 ############
######################################### # ############
######################################## ### ###########
####################################### 2 # 5 ##########
####################################### ################
##################################### 7 1 # 2 3 ########
# 4 2 5 7 1 2 3 N N 5 N ################5###############
########################################################                              
class Solution:
    def sumOfLongRootToLeafPath( self, root ):
        self.level = -1
        self.maxlevel = 0
        self.sum = 0
        self.maxsum = 0
        self.Longest_Journey( root )
        return self.maxsum
    def Longest_Journey( self, p ):
        if not p: return
        self.level += 1
        self.sum += p.data
        if p.left == p.right:
            if self.level > self.maxlevel:
                self.maxlevel = self.level
                self.maxsum = self.sum
            elif self.level == self.maxlevel:
                if self.sum > self.maxsum:
                    self.maxsum = self.sum
        self.Longest_Journey( p.left )
        self.Longest_Journey( p.right )
        self.sum -= p.data
        self.level -= 1
########################################################
########################################################
########################################################
########################################################
from collections import deque ##########################
########################################################
class Node: ############################################
    def __init__(self,val): ############################
        self.data=val ##################################
        self.left=None #################################
        self.right=None ################################
########################################################
def buildTree(s): ######################################
    if(len(s)==0 or s[0]=="N"): ########################
        return None ####################################
    ip=list(map(str,s.split())) ########################
    root=Node(int(ip[0])) ##############################
    size=0 #############################################
    q=deque() ##########################################
    q.append(root) #####################################
    size=size+1 ########################################
    i=1 ################################################
    while(size>0 and i<len(ip)): #######################
        currNode=q[0] ##################################
        q.popleft() ####################################
        size=size-1 ####################################
        currVal=ip[i] ##################################
        if(currVal!="N"): ##############################
            currNode.left=Node(int(currVal)) ###########
            q.append(currNode.left) ####################
            size=size+1 ################################
        i=i+1 ##########################################
        if(i>=len(ip)): ################################
            break ######################################
        currVal=ip[i] ##################################
        if(currVal!="N"): ##############################
            currNode.right=Node(int(currVal)) ##########
            q.append(currNode.right) ###################
            size=size+1 ################################
        i=i+1 ##########################################
    return root ########################################
########################################################
if __name__ == '__main__': #############################
    test_cases = int(input()) ##########################
    for cases in range(test_cases): ####################
        s=input() ######################################
        root=buildTree(s) ##############################
        ob = Solution() ################################
        res = ob.sumOfLongRootToLeafPath(root) #########
        print(res) #####################################
########################################################
#　あの　あの　あの　あの　あの　あの　あの　あの　あの
#　いま　いま　いま　いま　いま　いま　いま　いま　いま
#　えいご　えいご　えいご　えいご　えいご　えいご　えいご
#　ええ　ええ　ええ　ええ　ええ　ええ　ええ　ええ　ええ
#　がくせい　がくせい　がくせい　がくせい　がくせい　がくせい
#　〜ご　〜ご　〜ご　〜ご　〜ご　〜ご　〜ご　〜ご　〜ご
#　こいこい　こいこい　こいこい　こいこい　こいこい　こいこい
#　ごご　ごご　ごご　ごご　ごご　ごご　ごご　ごご　ごご
#　ごぜん　ごぜん　ごぜん　ごぜん　ごぜん　ごぜん　ごぜん
#　〜さい　〜さい　〜さい　〜さい　〜さい　〜さい　〜さい
#　〜さん　〜さん　〜さん　〜さん　〜さん　〜さん　〜さん
########################################################
########################################################
########################################################
########################################################
########################################################
########################################################
# Test Cases Passed:                         2111 / 2111
# Total Points Scored:                             4 / 4
# Your Total Score:                                 1298
# Total Time Taken:                                 1.01
