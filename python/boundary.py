################################################################
# Boundary Traversal of binary tree                            #
################################################################
# Given a Binary Tree, find its Boundary Traversal. The traversal
# should be in the following order: Left boundary nodes: defined
# as the path from the root to the left-most node i.e. the leaf node
# you could reach when you always travel preferring the left subtree
# over the right subtree. Leaf nodes: All the leaf nodes except for
# the ones that are part of left or right boundary. Reverse right
# boundary nodes: defined as the path from the right-most node to
# the root. The right-most node is the leaf node you could reach
# when you always travel preferring the right subtree over the left
# subtree. Exclude the root from this as it was already included
# in the traversal of left boundary nodes. Note: If the root doesn't
# have a left subtree or right subtree, then the root itself is the
# left or right boundary.
##################_#############################################
# Input:   1       Output: 1 2 4 8 9 6 7 3                     #
#         / \                                                  #
#        /   \                                                 #
#       /     \                                                #
#      2       3                                               #
#     / \     / \                                              #
#    4   5   6   7                                             #
#       8 9                                                    #
####################=###########################################
# Input:         1  Output: 1 2 4 6 5 7 8                      # 
#               /                                              #
#              /                                               #
#             /                                                #
#            /                                                 #
#           2                                                  #
#          / \                                                 #
#         /   \                                                #
#        4     9                                               #
#       / \     \                                              #
#      6   5     3                                             #
#               7 8 _                                          #
################################################################
# Expected Time Complexity: O( N )                             #
# Expected Auxiliary Space: O( Height of the Tree )            #
################################################################
################################################################
############################################################
############################################################
############################################################
############################################################
############################################################
############################################################
############################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
class Solution:
    """"""
    def __init__( self ):
        self.ls = []
        self.deq = deque()
        
    def insert( self, key ):
        self.ls.append( key )

    def enqueue( self, key ):
        self.deq.appendleft( key )

    def preorder( self, node ):
        """ Until Leaf """
        if not node: return
        if is_Leaf( node ): raise Leaf_Detected()
        self.insert( node.data )
        self.preorder( node.left )
        self.preorder( node.right )

    def inorder( self, node ):
        if not node: return
        self.inorder( node.left )
        if is_Leaf( node ): self.insert( node.data )
        self.inorder( node.right )

    def ryte_Preorder( self, node ):
        """ Autumn Leaves """
        if not node: return
        if is_Leaf( node ): raise Leaf_Detected()
        self.enqueue( node.data )
        self.ryte_Preorder( node.right )
        self.ryte_Preorder( node.left )
        
    def printBoundaryView( self, root ):
        if root:
            self.insert( root.data )
            if not is_Leaf( root ):
                try:
                    self.preorder( root.left )
                except Leaf_Detected:
                    pass
                self.inorder( root )
                try:
                    self.ryte_Preorder( root.right )
                except Leaf_Detected:
                    self.ls.extend( self.deq )
        return self.ls
    
###############################################################=
def is_Leaf( p ): return p.left == p.right
################################################################
class Leaf_Detected( Exception ): pass
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
############################==========1==========###############
############################=====2=========3=====###############
############################==4=====5===6=====7==###############
############################=8=9===N=N=a=N===N=b=###############
################################################################
################################_1_2_3_4_5_6_7_8_9_N_N_10_N_N_11
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
################################################################
from collections import deque ##################################
################################################################
class Node:#####################################################
    def __init__(self,val):#####################################
        self.right=None#########################################
        self.data=val###########################################
        self.left=None##########################################
################################################################
def buildTree(s):                            ###################
    if(len(s)==0 or s[0]=="N"):return None   ###################
    ip=list(map(str,s.split()))              ###################
    root=Node(int(ip[0]))                    ###################
    size=0                                   ###################
    q=deque()                                ###################
    q.append(root)                           ###################
    size=size+1                              ###################
    i=1                                      ###################
    while(size>0 and i<len(ip)):             ###################
        currNode=q[0]                        ###################
        q.popleft()                          ###################
        size=size-1                          ###################
        currVal=ip[i]                        ###################
        if(currVal!="N"):                    ###################
            currNode.left=Node(int(currVal)) ###################
            q.append(currNode.left)          ###################
            size=size+1                      ###################
        i=i+1                                ###################
        if(i>=len(ip)):break                 ###################
        currVal=ip[i]                        ###################
        if(currVal!="N"):                    ###################
            currNode.right=Node(int(currVal))###################
            q.append(currNode.right)         ###################
            size=size+1                      ###################
        i=i+1                                ###################
    return root                              ###################
################################################################
if __name__=="__main__":               #########################
    t=int(input())                     #########################
    for _ in range(0,t):               #########################
        s=input()                      #########################
        root=buildTree(s)              #########################
        obj=Solution()                 #########################
        res=obj.printBoundaryView(root)#########################
        for i in res:                  #########################
            print(i,end=" ")           #########################
        print('')                      #########################
################################################################
################################################################
################################################################
################################################################
# Test Cases Passed:                                     95 / 95
# Total Points Scored:                                     4 / 4
# Your Total Score:                                         1182
# Total Time Taken:                                          0.7
