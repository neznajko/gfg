                                  ////
////////////////////////////////////////////////////////////////////////
/* Construct Tree from Preorder Traversal 
 * Medium Accuracy: 50.68% Submissions: 13920 Points: 4
 ***********************************************************************
 * Construct a binary tree of size N using two given arrays pre[] and---
 * preLN[]. Array pre[] represents preorder traversal of a binary tree.-
 * Array preLN[] has only two possible values ‘L’ and ‘N’. The value ‘L’
 * in preLN[] indicates that the corresponding node in Binary Tree is a-
 * leaf node and value ‘N’ indicates that the corresponding node is a---
 * non-leaf node.-------------------------------------------------------
 * Note: Every node in the binary tree has either 0 or 2 children.------
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Your Task:  
 * You dont need to read input or print anything. Complete the function-
 * constructTree() which takes N, pre[] and preLN[] as input parameters-
 * and returns the root node of the constructed binary tree.------------
 * Note: The output generated by the compiler will contain the inorder--
 * traversal of the created binary tree.--------------------------------
 *\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
 * Expected Time Complexity: O(N)
 * Expected Auxiliary Space: O(N)                                     
 *//////////////////////////////////////////////////////////////////////
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
////////////////////////////////////////////////////////////////////////
class Node {
    int data;
    Node left;
    Node right;
    Node( int d) {
        data = d;
        left = right = null;
    }
}
////////////////////////////////////////////////////////////////////////
class GFG {
    public static void inorder( Node root) {
        if( root == null) return;
        inorder( root.left);
        System.out.print( root.data + " ");
        inorder( root.right);
    }
    ////////////////////////////////////////////////////////////////////           oo
    public static void main( String args[]) throws IOException {
        BufferedReader read = new BufferedReader( new InputStreamReader( System.in));
        int t = Integer.parseInt( read.readLine());
        while( t--> 0) {
            int n = Integer.parseInt( read.readLine());
            String input_line1[] = read.readLine().trim().split( "\\s+");
            int pre[] = new int[ n];
            for( int i = 0; i < n; i++) {
                pre[ i] = Integer.parseInt( input_line1[ i]);
            }
            String input_line2[] = read.readLine().trim().split( "\\s+");
            char preLN[] = new char[ n];
            for( int i = 0; i < n; i++) {
                preLN[ i] = input_line2[ i].charAt( 0);
            }
            Solution obj = new Solution();
            Node root = obj.constructTree( n, pre, preLN);
            inorder( root);
            System.out.println();
        }
    }
}
////////////////////////////////////////////////////////////////////////
// Here the important thing is that there is either 0 or 2 children bcoz
// otherwise it's not very well defined:
//    A, and A
//  /         \
// B            B, will give AB in preorder.
class Solution {
    int    n;    // en( that's not usez but Ok keep it here)
    int[]  ooda; // preorder
    char[] leaf; // is it or is it not?
    int    j;    // j the working horse
    Node cons() {                        // j: 0, 1, 2, 3, 4
        Node node = new Node( ooda[ j]); // 10
        if( leaf[ j] == 'L') {           // -- 30
            return node;                 //    -- 20
        }                                //    == 5
        j++;                             // == 15
        node.left = cons();              // 
        j++;                             //
        node.right = cons();             //
        return node;                     //
    }                                    //
    Node constructTree( int n, int pre[], char preLN[]) {
        this.n = n;
        ooda = pre;
        leaf = preLN;
        j = 0;
        return cons();
    }
}
////////////////////////////////////////////////////////////////////////
// log: Problem Solved Successfully( I Y E A G H ! ?)
// Total Points Scored:   Total Time Taken:
// 4/4                    2.5/5.5
////////////////////////////////////////////////////////////////////////
////                                                                ////
